---
name: code-review
description: コードレビューを実施するためのスキル。ユーザーがコードの品質、セキュリティ、テスト、パフォーマンス、アーキテクチャの観点からコードレビューを依頼した場合に使用します。「コードレビュー」「コードをチェック」「PRをレビュー」「このコードを確認して」などのコードレビュータスクに言及した場合にトリガーします。セキュリティ脆弱性、ロジックエラー、テスト品質、パフォーマンス問題を優先順位付けして指摘し、具体的な改善提案を行います。
---

# コードレビュー

コードの品質、セキュリティ、テスト、パフォーマンス、アーキテクチャの観点から包括的なコードレビューを実施します。

## レビュー優先順位

### 🔴 CRITICAL（マージブロック）

- **セキュリティ**: 脆弱性、シークレットの露出、認証/認可の問題
- **正確性**: ロジックエラー、データ破損リスク、競合状態
- **破壊的変更**: バージョニングなしの API 契約変更
- **データ損失**: データ損失・破損のリスク

### 🟡 IMPORTANT（要議論）

- **コード品質**: SOLID 原則の重大な違反、過度な重複
- **テストカバレッジ**: クリティカルパスや新機能のテスト欠落
- **パフォーマンス**: 明らかなボトルネック（N+1 クエリ、メモリリーク）
- **アーキテクチャ**: 確立されたパターンからの大幅な逸脱

### 🟢 SUGGESTION（非ブロッキング）

- **可読性**: 命名の問題、簡素化可能な複雑なロジック
- **最適化**: 機能に影響しないパフォーマンス改善
- **ベストプラクティス**: 慣習からの軽微な逸脱
- **ドキュメント**: 不足・不完全なコメント/ドキュメント

## レビューワークフロー

### 1. コンテキスト確認

レビュー開始前に以下を確認：

1. レビュー対象のコード範囲を特定
2. プロジェクトの技術スタック・アーキテクチャを把握
3. 変更の目的・背景を理解

### 2. 観点別レビュー

以下の観点で順にチェック：

1. **セキュリティ**: 脆弱性、機密データ、入力検証
2. **コード品質**: 命名、単一責任、DRY、エラーハンドリング
3. **テスト**: カバレッジ、テスト構造、エッジケース
4. **パフォーマンス**: N+1 クエリ、アルゴリズム、リソース管理
5. **アーキテクチャ**: 関心の分離、依存関係、パターン

各観点の詳細なチェック項目と例は [references/guide.md](references/guide.md) を参照。

### 3. コメント作成

レビューコメントは優先度とカテゴリを明示し、問題の説明・影響・修正案を含める。

コメントのフォーマットと例は [references/comment-template.md](references/comment-template.md) を参照。

## リファレンス

- **詳細ガイド**: [references/guide.md](references/guide.md) - 各観点のチェック項目と具体例
- **チェックリスト**: [references/checklist.md](references/checklist.md) - レビュー時の確認項目一覧
- **コメントテンプレート**: [references/comment-template.md](references/comment-template.md) - コメントの書き方と例

## レビュー原則

1. **具体的に**: 正確な行、ファイルを参照し、具体的な例を提供
2. **コンテキストを提供**: なぜ問題なのか、潜在的な影響を説明
3. **解決策を提案**: 間違いだけでなく、修正されたコードを示す
4. **建設的に**: 作者を批判するのではなく、コードの改善に焦点
5. **良い実践を認める**: 適切に書かれたコードやスマートな解決策を認める
6. **実用的に**: すべての提案が即座の実装を必要とするわけではない
7. **関連するコメントをグループ化**: 同じトピックについて複数のコメントを避ける
8. **根本原因を優先**: `@ts-ignore` や握りつぶしで回避せず、原因に対する修正を提案
9. **失敗系を必ず確認**: 正常系だけでなく、エラーケース・境界値・外部依存の失敗時動作を確認
10. **信頼性を重視**: 外部 API・ネットワーク処理にはタイムアウト、リトライ、観測可能なログの有無を確認
11. **セキュリティ前提で見る**: 入力検証、最小権限、秘密情報の環境変数管理をチェック
12. **計測ベースで判断**: 推測最適化を避け、N+1・過剰フェッチ・メモリ使用を根拠付きで指摘
13. **フェーズに応じて評価**: プロトタイプ/MVP/本番の段階に合わせて、要求品質と妥協点を明示
14. **技術的負債を可視化**: 今回見送る課題は、理由と後続対応（Issue/ADR など）を残す

## 設計・コーディング原則（追加）

レビュー時に、以下の設計・コーディング原則への適合も確認する。

1. **DRY**: 重複実装を避け、知識の単一情報源を保つ
2. **Tell, Don't Ask**: 状態問い合わせ中心の分岐より、振る舞いをオブジェクトに委譲する
3. **Skinny Controller, Fat Model**: Controller は入出力制御に集中し、業務ロジックはドメイン層へ寄せる
4. **SOLID**: 単一責務・拡張性・置換可能性・適切なインターフェース分離・抽象依存を確認する
5. **GRASP**: Information Expert / Creator / Low Coupling / High Cohesion を責務割り当ての判断軸にする
6. **KISS**: 過度に複雑な実装を避け、理解しやすく変更しやすい構造を優先する
7. **YAGNI**: 現時点で不要な機能や抽象化を先回り実装しない
8. **Composition over Inheritance**: 継承階層の肥大化を避け、委譲（コンポジション）を優先する
9. **Law of Demeter**: 長いメソッドチェーンを避け、直接の協調対象にのみ依存する
10. **Separation of Concerns**: UI・アプリケーション・ドメイン・インフラの関心を分離する
11. **Inversion of Control**: 依存関係の生成/解決を外部化し、DI を通じて疎結合を保つ
12. **Command Query Separation**: 状態変更（Command）と参照（Query）を分離する
